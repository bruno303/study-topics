// Code generated by MockGen. DO NOT EDIT.
// Source: planning-poker/internal/application (interfaces: UseCase,UseCaseR)
//
// Generated by this command:
//
//	mockgen -destination mocks.go -typed -package application . UseCase,UseCaseR
//

// Package application is a generated GoMock package.
package application

import (
	context "context"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockUseCase is a mock of UseCase interface.
type MockUseCase[In any] struct {
	ctrl     *gomock.Controller
	recorder *MockUseCaseMockRecorder[In]
	isgomock struct{}
}

// MockUseCaseMockRecorder is the mock recorder for MockUseCase.
type MockUseCaseMockRecorder[In any] struct {
	mock *MockUseCase[In]
}

// NewMockUseCase creates a new mock instance.
func NewMockUseCase[In any](ctrl *gomock.Controller) *MockUseCase[In] {
	mock := &MockUseCase[In]{ctrl: ctrl}
	mock.recorder = &MockUseCaseMockRecorder[In]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUseCase[In]) EXPECT() *MockUseCaseMockRecorder[In] {
	return m.recorder
}

// Execute mocks base method.
func (m *MockUseCase[In]) Execute(ctx context.Context, cmd In) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, cmd)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockUseCaseMockRecorder[In]) Execute(ctx, cmd any) *MockUseCaseExecuteCall[In] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockUseCase[In])(nil).Execute), ctx, cmd)
	return &MockUseCaseExecuteCall[In]{Call: call}
}

// MockUseCaseExecuteCall wrap *gomock.Call
type MockUseCaseExecuteCall[In any] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseExecuteCall[In]) Return(arg0 error) *MockUseCaseExecuteCall[In] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseExecuteCall[In]) Do(f func(context.Context, In) error) *MockUseCaseExecuteCall[In] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseExecuteCall[In]) DoAndReturn(f func(context.Context, In) error) *MockUseCaseExecuteCall[In] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockUseCaseR is a mock of UseCaseR interface.
type MockUseCaseR[In any, Out any] struct {
	ctrl     *gomock.Controller
	recorder *MockUseCaseRMockRecorder[In, Out]
	isgomock struct{}
}

// MockUseCaseRMockRecorder is the mock recorder for MockUseCaseR.
type MockUseCaseRMockRecorder[In any, Out any] struct {
	mock *MockUseCaseR[In, Out]
}

// NewMockUseCaseR creates a new mock instance.
func NewMockUseCaseR[In any, Out any](ctrl *gomock.Controller) *MockUseCaseR[In, Out] {
	mock := &MockUseCaseR[In, Out]{ctrl: ctrl}
	mock.recorder = &MockUseCaseRMockRecorder[In, Out]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUseCaseR[In, Out]) EXPECT() *MockUseCaseRMockRecorder[In, Out] {
	return m.recorder
}

// Execute mocks base method.
func (m *MockUseCaseR[In, Out]) Execute(ctx context.Context, cmd In) (Out, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, cmd)
	ret0, _ := ret[0].(Out)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute.
func (mr *MockUseCaseRMockRecorder[In, Out]) Execute(ctx, cmd any) *MockUseCaseRExecuteCall[In, Out] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockUseCaseR[In, Out])(nil).Execute), ctx, cmd)
	return &MockUseCaseRExecuteCall[In, Out]{Call: call}
}

// MockUseCaseRExecuteCall wrap *gomock.Call
type MockUseCaseRExecuteCall[In any, Out any] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseRExecuteCall[In, Out]) Return(arg0 Out, arg1 error) *MockUseCaseRExecuteCall[In, Out] {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseRExecuteCall[In, Out]) Do(f func(context.Context, In) (Out, error)) *MockUseCaseRExecuteCall[In, Out] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseRExecuteCall[In, Out]) DoAndReturn(f func(context.Context, In) (Out, error)) *MockUseCaseRExecuteCall[In, Out] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
